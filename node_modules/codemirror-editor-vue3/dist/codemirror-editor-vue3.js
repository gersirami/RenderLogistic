import { defineComponent as M, ref as x, onMounted as j, markRaw as T, watch as $, unref as k, openBlock as S, createElementBlock as E, computed as I, nextTick as K, shallowRef as Q, getCurrentInstance as X, onBeforeUnmount as Y, normalizeClass as ee, normalizeStyle as te, createBlock as ne, resolveDynamicComponent as re, mergeProps as oe } from "vue";
import "codemirror/lib/codemirror.css";
import "codemirror/addon/fold/foldgutter.css";
import "codemirror/addon/fold/foldcode.js";
import "codemirror/addon/fold/foldgutter.js";
import "codemirror/addon/fold/brace-fold.js";
import "codemirror/addon/selection/active-line.js";
import z from "codemirror";
import "codemirror/addon/merge/merge.css";
import "codemirror/addon/merge/merge.js";
import se from "diff-match-patch";
import "codemirror/addon/mode/simple.js";
!window.CodeMirror && (window.CodeMirror = z);
const _ = window.CodeMirror || z, ae = M({
  name: "DefaultMode",
  props: {
    name: {
      type: String,
      default: `cm-textarea-${+/* @__PURE__ */ new Date()}`
    },
    value: {
      type: String,
      default: ""
    },
    content: {
      type: String,
      default: ""
    },
    options: {
      type: Object,
      default: () => ({})
    },
    cminstance: {
      type: Object,
      default: () => null
    },
    placeholder: {
      type: String,
      default: ""
    }
  },
  emits: {
    ready: (e) => e,
    "update:cminstance": (e) => e
  },
  setup(e, { emit: n }) {
    const o = x(), t = x(null), r = () => {
      t.value = T(_.fromTextArea(o.value, e.options)), n("update:cminstance", t.value);
      const s = $(
        () => e.cminstance,
        (l) => {
          var m;
          l && ((m = e.cminstance) == null || m.setValue(e.value || e.content)), n("ready", k(t)), s == null || s();
        },
        { deep: !0 }
      );
    };
    return j(() => {
      r();
    }), {
      textarea: o,
      initialize: r
    };
  }
}), A = (e, n) => {
  const o = e.__vccOpts || e;
  for (const [t, r] of n)
    o[t] = r;
  return o;
}, le = ["name", "placeholder"];
function ie(e, n, o, t, r, s) {
  return S(), E("textarea", {
    ref: "textarea",
    name: e.$props.name,
    placeholder: e.$props.placeholder
  }, null, 8, le);
}
const H = /* @__PURE__ */ A(ae, [["render", ie]]);
window.diff_match_patch = se;
window.DIFF_DELETE = -1;
window.DIFF_INSERT = 1;
window.DIFF_EQUAL = 0;
const ce = M({
  name: "MergeMode",
  props: {
    options: {
      type: Object,
      default: () => ({})
    },
    cminstance: {
      type: Object,
      default: () => ({})
    }
  },
  emits: ["update:cminstance", "ready"],
  setup(e, { emit: n }) {
    const o = x(), t = x(), r = () => {
      o.value = T(
        _.MergeView(t.value, e.options)
      ), n("update:cminstance", o.value), n("ready", o);
    };
    return j(() => {
      r();
    }), {
      mergeView: t,
      initialize: r
    };
  }
}), ue = { ref: "mergeView" };
function de(e, n, o, t, r, s) {
  return S(), E("div", ue, null, 512);
}
const pe = /* @__PURE__ */ A(ce, [["render", de]]);
var me = /* @__PURE__ */ ((e) => (e.info = "info", e.warning = "warning", e.error = "error", e))(me || {});
function ge() {
  const e = /* @__PURE__ */ new Date(), n = e.getHours() < 10 ? `0${e.getHours()}` : e.getHours(), o = e.getMinutes() < 10 ? `0${e.getMinutes()}` : e.getMinutes(), t = e.getSeconds() < 10 ? `0${e.getSeconds()}` : e.getSeconds();
  return `${n}:${o}:${t}`;
}
function He(e) {
  return `#link#${JSON.stringify(e)}#link#`;
}
function fe(e) {
  const n = /#link#(.+)#link#/g, o = [];
  let t;
  for (t = n.exec(e); t; ) {
    const r = document.createElement("a"), s = JSON.parse(t[1]), l = Object.entries(s);
    for (const [m, u] of l)
      r.setAttribute(m, u);
    r.className = "editor_custom_link", r.innerHTML = "logDownload", o.push({
      start: t.index,
      end: t.index + t[0].length,
      node: r
    }), t = n.exec(e);
  }
  return o;
}
function Re(e = "", n = "info") {
  return `#log<${n}>log#${e}#log<${n}>log#`;
}
function he(e) {
  const n = [];
  function o() {
    const t = /#log<(\w*)>log#((.|\r\n|\n)*?)#log<(\w*)>log#/g;
    let r;
    for (r = t.exec(e); r; ) {
      const l = r[0].replace(/\r\n/g, `
`).split(`
`), u = r[2].replace(/\r\n/g, `
`).split(`
`), d = document.createElement("span"), i = r[1];
      d.className = `c-editor--log__${i}`;
      let p = 0;
      for (let a = 0; a < l.length; a++) {
        const g = l[a], v = u[a], y = d.cloneNode(!1);
        y.innerText = v, n.push({
          start: r.index + p,
          end: r.index + p + g.length,
          node: y
        }), p = p + g.length + 1;
      }
      r = t.exec(e);
    }
  }
  return o(), n;
}
function ze(e, n) {
  return `[${ge()}] <${n}> ${e}`;
}
function Be(e, n, o) {
  const r = new Array(Math.max(n || 15, 5)).join(o || "=");
  return `${r}${e}${r}`;
}
const C = [
  {
    regex: /(\[.*?\])([ \t]*)(<error>[ \t])(.+)/,
    token: ["tag", "", "error.strong", "error.strong"],
    sol: !0
    // next: "error",
  },
  {
    regex: /(\[.*?\])([ \t]*)(<info>)(.+)(.?)/,
    token: ["tag", "", "bracket", "bracket", "hr"],
    sol: !0
    // next: "info",
  },
  {
    regex: /(\[.*?\])([ \t]*)(<warning>)(.+)(.?)/,
    token: ["tag", "", "comment", "comment", "hr"],
    sol: !0
    // next: "warning",
  }
];
_.defineSimpleMode("fclog", {
  start: [
    ...C,
    {
      regex: /.*/,
      token: "hr"
    }
  ],
  error: [
    ...C,
    {
      regex: /.*/,
      token: "error.strong"
    }
  ],
  info: [
    ...C,
    {
      regex: /.*/,
      token: "bracket"
    }
  ],
  warning: [
    ...C,
    {
      regex: /.*\[/,
      token: "comment"
    }
  ]
});
_.defineSimpleMode("log", {
  start: [
    {
      regex: /^[=]+[^=]*[=]+/,
      token: "strong"
    },
    {
      regex: /([^\w])([A-Z][\w]*)/,
      token: ["", "string"]
    },
    {
      regex: /(^[A-Z][\w]*)/,
      token: "string"
    }
    // {
    //     regex: /([^\d])([0-9]+)/,
    //     token: [null, 'comment']
    // },
    // {
    //     regex: /(^[0-9]+)/,
    //     token: 'comment'
    // }
  ]
});
const ve = M({
  name: "CodemirrorFclog",
  props: {
    value: {
      type: String,
      default: ""
    },
    name: {
      type: String,
      default: `cm-textarea-${+/* @__PURE__ */ new Date()}`
    },
    options: {
      type: Object,
      default: () => ({})
    },
    cminstance: {
      type: Object,
      default: () => ({})
    },
    placeholder: {
      type: String,
      default: ""
    }
  },
  emits: ["update:cminstance", "ready"],
  setup(e, { emit: n }) {
    const o = x(), t = x(null), r = (l = e.cminstance) => {
      l.getAllMarks().forEach((i) => i.clear());
      const u = l.getValue(), d = [].concat(fe(u)).concat(he(u));
      for (let i = 0; i < d.length; i++) {
        const p = d[i];
        l.markText(
          l.posFromIndex(p.start),
          l.posFromIndex(p.end),
          { replacedWith: p.node }
        );
      }
    }, s = () => {
      var l;
      t.value = T(_.fromTextArea(o.value, e.options)), n("update:cminstance", k(t)), (l = t.value) == null || l.on("change", r);
    };
    return $(
      () => e.cminstance,
      (l) => {
        var m;
        l && (r(e.cminstance), (m = e.cminstance) == null || m.setValue(e.value), n("ready", t));
      },
      { deep: !0, immediate: !0 }
    ), j(() => {
      s();
    }), {
      initialize: s,
      textarea: o
    };
  }
}), ye = ["name", "placeholder"];
function ke(e, n, o, t, r, s) {
  return S(), E("textarea", {
    ref: "textarea",
    name: e.$props.name,
    placeholder: e.$props.placeholder
  }, null, 8, ye);
}
const xe = /* @__PURE__ */ A(ve, [["render", ke]]), B = {
  "update:value": () => !0,
  change: (e, n) => ({ value: e, cm: n }),
  input: () => !0,
  ready: (e) => e
}, we = [
  "changes",
  "scroll",
  "beforeChange",
  "cursorActivity",
  "keyHandled",
  "inputRead",
  "electricInput",
  "beforeSelectionChange",
  "viewportChange",
  "swapDoc",
  "gutterClick",
  "gutterContextMenu",
  "focus",
  "blur",
  "refresh",
  "optionChange",
  "scrollCursorIntoView",
  "update"
], $e = () => {
  const e = {};
  return we.forEach((n) => {
    e[n] = (...o) => o;
  }), e;
}, _e = { ...B, ...$e() }, L = {
  mode: "text",
  // Language mode
  theme: "default",
  // Theme
  lineNumbers: !0,
  // Display line number
  smartIndent: !0,
  // Intelligent indentation
  indentUnit: 2,
  styleActiveLine: !0
};
function Se(e) {
  Promise.resolve().then(() => {
    const n = e.getScrollInfo();
    e.scrollTo(n.left, n.height);
  });
}
const be = ({
  props: e,
  cminstance: n,
  emit: o,
  internalInstance: t,
  content: r
}) => {
  const s = I(
    () => {
      var u;
      return e.merge ? (u = k(n)) == null ? void 0 : u.editor() : k(n);
    }
  ), l = () => {
    const u = [];
    return Object.keys(t == null ? void 0 : t.vnode.props).forEach((d) => {
      if (d.startsWith("on")) {
        const i = d.replace(d[2], d[2].toLowerCase()).slice(2);
        !B[i] && u.push(i);
      }
    }), u;
  };
  return {
    listenerEvents: () => {
      s.value.on("change", (i) => {
        const p = i.getValue();
        p === r.value && p !== "" || (r.value = p, o("update:value", r.value || ""), o("input", r.value || " "), Promise.resolve().then(() => {
          o("change", r.value, i);
        }), e.keepCursorInEnd && Se(i));
      });
      const u = {};
      l().filter((i) => !u[i] && (u[i] = !0)).forEach((i) => {
        s.value.on(i, (...p) => {
          o(i, ...p);
        });
      });
    }
  };
};
function Ce({ props: e, cminstance: n, presetRef: o }) {
  const t = x("100%"), r = x("100%"), s = I(
    () => {
      var a;
      return e.merge ? (a = k(n)) == null ? void 0 : a.editor() : k(n);
    }
  ), l = () => {
    K(() => {
      var a;
      (a = s.value) == null || a.refresh();
    });
  }, m = (a = e.width, g = e.height) => {
    var b;
    let v = "", y = "";
    String(a).includes("%") ? (y = "100%", t.value = String(a)) : (y = String(a).replace("px", ""), t.value = `${y}px`), String(g).includes("%") ? (v = "100%", r.value = String(g)) : (v = String(g).replace("px", ""), r.value = `${v}px`), (b = s.value) == null || b.setSize(y, v);
  }, u = () => {
    var g;
    const a = (g = s.value) == null ? void 0 : g.getWrapperElement();
    a == null || a.remove();
  }, d = () => {
    var g, v, y;
    const a = (g = s.value) == null ? void 0 : g.getDoc().getHistory();
    (v = o.value) == null || v.initialize(), u(), (y = s.value) == null || y.getDoc().setHistory(a);
  }, i = () => {
    const a = document.querySelector(".CodeMirror-gutters");
    return (a == null ? void 0 : a.style.left.replace("px", "")) !== "0";
  };
  return {
    reload: d,
    refresh: l,
    resize: m,
    destroy: u,
    containerWidth: t,
    containerHeight: r,
    reviseStyle: () => {
      if (l(), !i())
        return;
      const a = setInterval(() => {
        i() ? l() : clearInterval(a);
      }, 60), g = setTimeout(() => {
        clearInterval(a), clearTimeout(g);
      }, 400);
    }
  };
}
const R = /* @__PURE__ */ M({
  __name: "index",
  props: {
    value: {
      type: String,
      default: ""
    },
    options: {
      type: Object,
      default: () => L
    },
    globalOptions: {
      type: Object,
      default: () => L
    },
    placeholder: {
      type: String,
      default: ""
    },
    border: {
      type: Boolean,
      default: !1
    },
    width: {
      type: [String, Number],
      default: null
    },
    height: {
      type: [String, Number],
      default: null
    },
    originalStyle: {
      type: Boolean,
      default: !1
    },
    keepCursorInEnd: {
      type: Boolean,
      default: !1
    },
    merge: {
      type: Boolean,
      default: !1
    },
    name: {
      type: String,
      default: ""
    },
    marker: {
      type: Function,
      default: () => null
    },
    unseenLines: {
      type: Array,
      default: () => []
    }
  },
  emits: _e,
  setup(e, { expose: n, emit: o }) {
    var N, V, F;
    typeof Object.assign != "function" && Object.defineProperty(Object, "assign", {
      value(c) {
        if (c == null)
          throw new TypeError("Cannot convert undefined or null to object");
        const f = Object(c);
        for (let h = 1; h < arguments.length; h++) {
          const w = arguments[h];
          if (w != null)
            for (const O in w)
              Object.prototype.hasOwnProperty.call(w, O) && (f[O] = w[O]);
        }
        return f;
      },
      writable: !0,
      configurable: !0
    });
    const t = e, r = o, s = x(null), l = x(""), m = Q(H), u = x({
      foldGutter: !0,
      ...L,
      ...t.globalOptions,
      ...t.options,
      gutters: [
        .../* @__PURE__ */ new Set([
          "CodeMirror-linenumbers",
          "CodeMirror-foldgutter",
          ...((N = t.options) == null ? void 0 : N.gutters) || []
        ])
      ]
    }), d = X(), i = t.name || ((F = (V = d == null ? void 0 : d.parent) == null ? void 0 : V.type) == null ? void 0 : F.name) || void 0, p = x(null), a = I(() => {
      var c;
      return t.merge ? (c = k(s)) == null ? void 0 : c.editor() : k(s);
    }), {
      refresh: g,
      resize: v,
      destroy: y,
      containerHeight: b,
      containerWidth: U,
      reviseStyle: W
    } = Ce({
      props: t,
      cminstance: s,
      presetRef: p
    }), { listenerEvents: G } = be({
      props: t,
      cminstance: s,
      emit: r,
      internalInstance: d,
      content: l
    }), D = () => {
      t.unseenLines !== void 0 && t.marker !== void 0 && t.unseenLines.forEach((c) => {
        var h, w;
        const f = (h = s.value) == null ? void 0 : h.lineInfo(c);
        (w = s.value) == null || w.setGutterMarker(
          c,
          "breakpoints",
          f != null && f.gutterMarkers ? null : t.marker()
        );
      });
    }, J = (c) => {
      var h, w;
      const f = (h = s.value) == null ? void 0 : h.getValue();
      c !== f && ((w = s.value) == null || w.setValue(c), l.value = c, W()), D();
    }, Z = () => {
      G(), D(), v(t.width, t.height), r("ready", s.value), $(
        [() => t.width, () => t.height],
        ([c, f]) => {
          v(c, f);
        },
        { deep: !0 }
      );
    }, q = () => {
      if (t.options.mode === "fclog" || t.options.mode === "log") {
        m.value = xe;
        return;
      }
      if (t.merge) {
        m.value = pe;
        return;
      }
      m.value = H;
    };
    return $(
      () => t.options,
      (c) => {
        var f;
        for (const h in t.options)
          (f = a.value) == null || f.setOption(
            h,
            k(c[h])
          );
      },
      { deep: !0 }
    ), $(
      () => t.value,
      (c) => {
        J(c);
      }
    ), $(() => t.merge, q, { immediate: !0 }), Y(() => {
      y();
    }), n({
      cminstance: s,
      resize: v,
      refresh: g,
      destroy: y
    }), (c, f) => (S(), E("div", {
      class: ee(["codemirror-container", {
        merge: c.$props.merge,
        bordered: c.$props.border || c.$props.merge && !t.originalStyle,
        "original-style": t.originalStyle
      }]),
      style: te({
        height: k(b),
        width: k(U)
      })
    }, [
      (S(), ne(re(m.value), oe({
        ref_key: "presetRef",
        ref: p,
        cminstance: s.value,
        "onUpdate:cminstance": f[0] || (f[0] = (h) => s.value = h),
        style: { height: "100%" }
      }, {
        ...c.$props,
        ...c.$attrs,
        options: u.value,
        name: k(i),
        content: l.value
      }, { onReady: Z }), null, 16, ["cminstance"]))
    ], 6));
  }
}), P = (e, n) => (n && n.options && (R.props.globalOptions.default = () => n.options), e.component((n == null ? void 0 : n.componentName) || "Codemirror", R), e), Pe = window.CodeMirror || _, Ue = P, We = P;
function styleInject(css,ref){if(ref===void 0){ref={}}var insertAt=ref.insertAt;if(!css||typeof document==="undefined"){return}var head=document.head||document.getElementsByTagName("head")[0];var style=document.createElement("style");style.type="text/css";if(insertAt==="top"){if(head.firstChild){head.insertBefore(style,head.firstChild)}else{head.appendChild(style)}}else{head.appendChild(style)}if(style.styleSheet){style.styleSheet.cssText=css}else{style.appendChild(document.createTextNode(css))}};styleInject(`.codemirror-container {
  position: relative;
  display: inline-block;
  height: 100%;
  width: fit-content;
  font-size: 13px;
  overflow: hidden;
}
.codemirror-container.bordered {
    border: 1px solid #aaaaaa;
}

.codemirror-container .editor_custom_link {
  cursor: pointer;
  color: #1474f1;
  text-decoration: underline;
}
.codemirror-container .editor_custom_link:hover {
  color: #04b4fa;
}
.codemirror-container:not(.original-style) .CodeMirror-lines .CodeMirror-placeholder.CodeMirror-line-like {
  color: #666;
}
.codemirror-container:not(.original-style) .CodeMirror,
.codemirror-container:not(.original-style) .CodeMirror-merge-pane {
  height: 100%;
  font-family: consolas !important;
}
.codemirror-container:not(.original-style) .CodeMirror-merge,
.codemirror-container:not(.original-style) .CodeMirror-merge-right .CodeMirror {
  height: 100%;
  border: none !important;
}
.codemirror-container:not(.original-style) .c-editor--log__error {
  color: #bb0606;
  font-weight: bold;
}
.codemirror-container:not(.original-style) .c-editor--log__info {
  color: #333333;
  font-weight: bold;
}
.codemirror-container:not(.original-style) .c-editor--log__warning {
  color: #ee9900;
}
.codemirror-container:not(.original-style) .c-editor--log__success {
  color: #669600;
}
.codemirror-container:not(.original-style) .cm-header,
.codemirror-container:not(.original-style) .cm-strong {
  font-weight: bold;
}
`);
export {
  Pe as CodeMirror,
  Ue as GlobalCmComponent,
  We as InstallCodemirro,
  R as VueCodemirror,
  He as createLinkMark,
  ze as createLog,
  Re as createLogMark,
  Be as createTitle,
  R as default,
  fe as getLinkMarks,
  ge as getLocalTime,
  he as getLogMark,
  me as logErrorType
};
